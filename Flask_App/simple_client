
'''
simple flask app to fetch data build a bundle and send as $process-message operation
'''

from flask import Flask, request, render_template, jsonify
from requests import get
from json import dumps, loads
from pathlib import path
from datetime import datetime
import fhirtemplates

import fhirclient.r4models.bundle as B
import fhirclient.r4models.encounter as Enc
import fhirclient.r4models.patient as P
import fhirclient.r4models.practitioner as Pract
import fhirclient.r4models.organization as Org
import fhirclient.r4models.coverage as Cov
import fhirclient.r4models.location as Loc
import fhirclient.r4models.fhirreference as FRef
import fhirclient.r4models.fhirdate as FDate
import fhirclient.r4models.codeableconcept as CC
import fhirclient.r4models.coding as Coding

import logging
#logging.disable(logging.CRITICAL)
logging.basicConfig(filename='myProgram.log',level=logging.DEBUG, format=' %(asctime)s - %(levelname)s- %(message)s')
logging.debug('Start of program')
logging.info('The logging module is working.')

ref_server = 'http://sqlonfhir-stu3.azurewebsites.net/fhir'
alerts_server = 'https://ttbfdsk0pc.execute-api.us-east-1.amazonaws.com/dev'

headers = {
    'Accept':'application/fhir+json',
    'Content-Type':'application/fhir+json'
    }

# profile = 'http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient' # The official URL for this profile is: http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient

now = str(datetime.datetime.utcnow().isoformat()) # get url freindly time stamp

application = Flask(__name__)

def fetch(t_type,**kwargs):
    '''
    fetch resource by search parameters e.g. _id
    '''
    r_url = f'{ref_server}/{r_type}'
    with get(r_url, headers=headers, params=kwargs) as f:
        if r.status_code < 300:
            return()

def process_message(data):
    '''
    upload message to process-message endpoint
    return operation outcome
    '''
    with post(alerts_server, headers=headers, data = json.dumps(data)) as r:
    #logging.info('url= {}\nr.status_code ={}\nr.reason={}\nr.headers=\nr.json()={}'.format(ref_server,r.status_code, r.reason, r.headers, r.json()))
        return (r.status_code, r.reason, r.headers, r.json())

def bundler(resources):  # message bundle
    logging.info("starting bundler...")
    new_bundle = Bundle.Bundle()
    new_bundle.id = 'davinci-notifications-bundle-{timestamp()}'
    new_bundle.type = 'message'
    new_bundle.timestamp = now
    new_bundle.entry = []
    entry_id_map = {}
    for res in resources:  #  append list of resources create replace id with uuids.
        logging.info('res ={}'.format(res))
        entry = Bundle.BundleEntry()
        #get new uuid
        entry.fullUrl = '{}/{}/{}'.format(ref_server, res.resource_type, res.id)
        entry.resource = res
        new_bundle.entry.append(entry)
    logging.info('new_bundle={}'.format(new_bundle.as_json()))
    return(new_bundle)

@application.route('/', methods=['GET', 'POST'])  # decorator to map to home page
def index():
    global ref_server
    '''
    if request.method == 'POST':
        ref_server = request.form['options']
    '''
    return render_template('index.html', ref_server = ref_server)

@application.route('/<rt>/<r_id>')  # decorator to map for a FHIR Resource fetch encounter
def fhir_fetch(rt, r_id):  # rt = resource type id = resource id
    '''
    General approach
    fetch encounter,
    create messageheader, coverage, orgs 1 and 2
    fetch graph of resources as list
    create bundle
    '''

    sp = dict(request.args)  # sp = search parameters everything after the ?

    encounter = fetch(rt, _id=r_id) # fetch encounter resource by id as pymodel

    patient = fetch(rt, _id=encounter.subject.reference[8]) # fetch patient
    location = fetch(rt, _id=encounter.location[0].location.reference[9]) # fetch location
    practitioner = fetch(rt, _id=encounter.participant[0].individual.reference[10]) # fetch practitioner
    organization1 = fetch(rt, _id=encounter.serviceprovider.reference[13]) # fetch org
    condition = fetch(rt, patient=patient.id, encounter=encounter.id) # fetch condition

    messageheader = fhirtemplates.messageheader.format(
        patient_id=patient.id,
        responsible=organization1.id
        sender = organization2.id)
        author = organization#create messageheader as dict hardcode as admit for now,
    coverage = t.messageheader.format()#create messageheader as dict hardcode as admit for now,
    organization4 = t.messageheader.format()#create messageheader as dict hardcode as admit for now,

    return fhirtemplates.fetch_resource_return.format(rt, r_id, res_narr, json.dumps(dict(res.json()), sort_keys=True, indent=4))

@application.route('/$process-message'methods=['POST'])  # decorator to POST for alerts server
def process_method(): # fhir_op
    '''
    General approach 1. Post to server and present to user server response
    '''
    process_message(message)  # how to access message object

    # get search bundle back with Appointments

    id_sp = {'_id':','.join([appt.id for appt in appts])} # get appt ids for search ad ?_id=id1,id2,id3,...
    logging.info('id_sp = {}'.format(id_sp))
    status_code, reason, headers, res_json, res_id, res_narr = search(ref_server, rt, id_sp) # return a tuple access with usual operations  note the json.dumps(dict(r.headers)) make case insensitive dict makes possible to dump# get appts from the ref_server


    try:
        return fhirtemplates.operation_find_return.format( op, '<ol><li>{}</li></ol>'.format('</li><li>'.join([i for i in res_id])), '<ol><li>{}</li></ol>'.format('</li> <li>'.join([i for i in res_narr])), json.dumps(dict(res_json), sort_keys=True, indent=4))
    except TypeError:
        return fhirtemplates.operation_find_exception_return.format(op)


# run the app.
if __name__ == "__main__":
    # Setting debug to True enables debug output. This line should be
    # removed before deploying a production app.
    application.debug = True
    application.run()
